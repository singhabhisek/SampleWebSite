import os
import xml.etree.ElementTree as ET
import zipfile
from urllib.parse import urlparse
import sys

# Extracts relevant session data from a Fiddler SAZ archive
def extract_sessions_from_saz(saz_file_path, allowed_hosts, skip_file_types):
    sessions = {}

    try:
        with zipfile.ZipFile(saz_file_path, 'r') as saz_file:
            for file_info in saz_file.infolist():
                # Read request data
                if file_info.filename.endswith('_c.txt'):
                    session_id = file_info.filename.replace('_c.txt', '')
                    try:
                        with saz_file.open(file_info) as file:
                            session_data = file.read().decode('utf-8')

                            # Skip if file type is blacklisted
                            if any(ext in session_data.lower() for ext in skip_file_types):
                                continue

                            # Extract host
                            lines = session_data.split('\n')
                            host_line = next((line for line in lines if line.lower().startswith('host:')), None)
                            if not host_line:
                                continue

                            host = host_line.split(':', 1)[1].strip()

                            # Skip if not in allowed_hosts (unless allowed_hosts is empty)
                            if allowed_hosts and host not in allowed_hosts:
                                continue

                            # Store the session
                            sessions[session_id] = {'data': session_data, 'comment': '', 'status_code': None}
                    except UnicodeDecodeError:
                        continue

                # Extract metadata or response status
                elif file_info.filename.endswith('_m.xml') or file_info.filename.endswith('_s.txt'):
                    session_id = file_info.filename.replace('_m.xml', '').replace('_s.txt', '')
                    if session_id not in sessions:
                        continue

                    # Metadata (comments)
                    if file_info.filename.endswith('_m.xml'):
                        with saz_file.open(file_info) as file:
                            xml_data = file.read().decode('utf-8')
                            root = ET.fromstring(xml_data)
                            ui_comment_element = root.find(".//SessionFlag[@N='ui-comments']")
                            ui_comment = ui_comment_element.get('V') if ui_comment_element is not None else ''
                            sessions[session_id]['comment'] = ui_comment

                    # Response status
                    elif file_info.filename.endswith('_s.txt'):
                        with saz_file.open(file_info, 'r') as file:
                            lines = file.readlines()
                            status_line = lines[0].decode('utf-8').strip()
                            status_code = status_line.split(' ')[1]
                            sessions[session_id]['status_code'] = status_code

    except Exception as e:
        print(f"Error extracting sessions: {e}")

    return sessions

# Parse HTTP request line, headers, and body
def parse_fiddler_session(session_data):
    try:
        lines = session_data['data'].strip().split('\r\n')
        request_line_parts = lines[0].split(' ')
        request_method = request_line_parts[0]
        url = request_line_parts[1]
        headers = {}
        body_start = False
        body = ''
        comment = session_data['comment']
        status_code = session_data.get('status_code')

        for line in lines[1:]:
            if line.strip() == '':
                body_start = True
                continue
            if body_start:
                body += line + '\n'
            else:
                if ':' in line:
                    key, value = line.split(':', 1)
                    headers[key.strip()] = value.strip()

        return request_method, url, headers, body.strip(), comment, status_code
    except Exception as e:
        print(f"Error parsing session: {e}")
        return None, None, None, None, None, None

# Extract domain and path from URL
def parse_url(url):
    try:
        parsed = urlparse(url)
        domain = parsed.netloc.split(':')[0]
        path = parsed.path
        return domain, path
    except Exception as e:
        print(f"Error parsing URL: {e}")
        return None, None

# Generates the JMeter .jmx XML structure based on session data
def generate_jmeter_test_plan(sessions, allowed_hosts, allowed_status_codes, saz_file_path):
    try:
        # Root test plan
        test_plan = ET.Element('jmeterTestPlan', version="1.2", properties="5.0", jmeter="5.5")
        hash_tree_main = ET.SubElement(test_plan, 'hashTree')

        # Test Plan metadata
        test_plan_elem = ET.SubElement(hash_tree_main, 'TestPlan', guiclass="TestPlanGui", testclass="TestPlan", testname="Test Plan", enabled="true")
        ET.SubElement(test_plan_elem, 'stringProp', name="TestPlan.comments")
        ET.SubElement(test_plan_elem, 'boolProp', name="TestPlan.functional_mode").text = "false"
        ET.SubElement(test_plan_elem, 'boolProp', name="TestPlan.tearDown_on_shutdown").text = "true"
        ET.SubElement(test_plan_elem, 'boolProp', name="TestPlan.serialize_threadgroups").text = "false"

        # User defined variables (none for now)
        user_defined_vars = ET.SubElement(test_plan_elem, 'elementProp', name="TestPlan.user_defined_variables", elementType="Arguments")
        ET.SubElement(user_defined_vars, 'collectionProp', name="Arguments.arguments")
        ET.SubElement(test_plan_elem, 'stringProp', name="TestPlan.user_define_classpath")

        hash_tree_after_test_plan = ET.SubElement(hash_tree_main, 'hashTree')

        # Thread Group setup
        thread_group = ET.SubElement(hash_tree_after_test_plan, 'ThreadGroup', guiclass="ThreadGroupGui", testclass="ThreadGroup", testname="Thread Group", enabled="true")
        ET.SubElement(thread_group, 'stringProp', name="ThreadGroup.on_sample_error").text = "continue"

        loop_controller = ET.SubElement(thread_group, 'elementProp', name="ThreadGroup.main_controller", elementType="LoopController")
        ET.SubElement(loop_controller, 'boolProp', name="LoopController.continue_forever").text = "false"
        ET.SubElement(loop_controller, 'stringProp', name="LoopController.loops").text = "1"

        ET.SubElement(thread_group, 'stringProp', name="ThreadGroup.num_threads").text = "1"
        ET.SubElement(thread_group, 'stringProp', name="ThreadGroup.ramp_time").text = "1"
        ET.SubElement(thread_group, 'boolProp', name="ThreadGroup.scheduler").text = "false"
        ET.SubElement(thread_group, 'boolProp', name="ThreadGroup.same_user_on_next_iteration").text = "true"

        hash_tree_for_samplers = ET.SubElement(hash_tree_after_test_plan, 'hashTree')

        current_transaction_controller = None
        last_comment = None

        # Loop through sessions
        for session_id, session_data in sessions.items():
            request_method, url, headers, body, comment, status_code = parse_fiddler_session(session_data)
            domain, path = parse_url(url)

            if not domain:
                continue

            # Filter by host or status code
            if (allowed_hosts and domain not in allowed_hosts) or (allowed_status_codes and status_code not in allowed_status_codes):
                continue

            # Create a new transaction controller group if comment has changed
            if comment != last_comment:
                current_transaction_controller = ET.SubElement(hash_tree_for_samplers, 'TransactionController', guiclass="TransactionControllerGui", testclass="TransactionController", testname=comment or "Group", enabled="true")
                ET.SubElement(current_transaction_controller, 'boolProp', name="TransactionController.includeTimers").text = "false"
                ET.SubElement(current_transaction_controller, 'boolProp', name="TransactionController.parent").text = "false"
                hash_tree_for_transaction = ET.SubElement(hash_tree_for_samplers, 'hashTree')

            # Create HTTP sampler
            http_sampler = ET.SubElement(hash_tree_for_transaction, 'HTTPSamplerProxy', guiclass="HttpTestSampleGui", testclass="HTTPSamplerProxy", testname=f"{request_method} {path}", enabled="true")

            # Handle POST body
            if request_method == 'POST':
                ET.SubElement(http_sampler, 'boolProp', name="HTTPSampler.postBodyRaw").text = "true"
                arguments = ET.SubElement(http_sampler, 'elementProp', name="HTTPsampler.Arguments", elementType="Arguments")
                collection_prop = ET.SubElement(arguments, 'collectionProp', name="Arguments.arguments")
                arg_element = ET.SubElement(collection_prop, 'elementProp', name="", elementType="HTTPArgument")
                ET.SubElement(arg_element, 'boolProp', name="HTTPArgument.always_encode").text = "false"
                ET.SubElement(arg_element, 'stringProp', name="Argument.value").text = body
                ET.SubElement(arg_element, 'stringProp', name="Argument.metadata").text = "="

            # Set sampler attributes
            ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.domain").text = domain
            if url.startswith('http://'):
                ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.port").text = "80"
                ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.protocol").text = "http"
            else:
                ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.port").text = "443"
                ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.protocol").text = "https"

            ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.path").text = path
            ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.method").text = request_method
            ET.SubElement(http_sampler, 'boolProp', name="HTTPSampler.follow_redirects").text = "true"
            ET.SubElement(http_sampler, 'boolProp', name="HTTPSampler.auto_redirects").text = "false"
            ET.SubElement(http_sampler, 'boolProp', name="HTTPSampler.use_keepalive").text = "true"
            ET.SubElement(http_sampler, 'boolProp', name="HTTPSampler.DO_MULTIPART_POST").text = "false"

            # Add hashTree node for sampler
            ET.SubElement(hash_tree_for_transaction, 'hashTree')

            last_comment = comment

        # Write JMX to file
        jmx_file_path = os.path.splitext(saz_file_path)[0] + '.jmx'
        tree = ET.ElementTree(test_plan)
        tree.write(jmx_file_path, encoding="utf-8", xml_declaration=True)

    except Exception as e:
        print(f"Error generating JMeter test plan: {e}")

if __name__ == "__main__":
    saz_file_path = sys.argv[1]

    # Parse allowed hosts from CLI args (optional)
    allowed_hosts = sys.argv[2].split(',') if len(sys.argv) > 2 and sys.argv[2] else []

    # Filter: only these status codes are considered valid
    allowed_status_codes = ["200", "302"]

    # Skip common static file types
    skip_file_types = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.css', '.js', '.woff', '.woff2', '.ttf', '.otf', '.svg']

    # Step 1: Extract sessions
    sessions = extract_sessions_from_saz(saz_file_path, allowed_hosts, skip_file_types)

    # If no host filter is provided, consider all unique hosts found
    if not allowed_hosts:
        allowed_hosts = list({parse_url(parse_fiddler_session(data)[1])[0] for data in sessions.values()})

    # Step 2: Generate the JMX file
    generate_jmeter_test_plan(sessions, allowed_hosts, allowed_status_codes, saz_file_path)

    # Step 3: Print all unique domains used
    all_hosts = {parse_url(parse_fiddler_session(data)[1])[0] for data in sessions.values()}
    print("\nâœ… JMeter test plan generated successfully!")
    print("ðŸ“¡ Unique hosts in the JMX file:")
    for host in sorted(all_hosts):
        print(f" - {host}")

===

import os
import xml.etree.ElementTree as ET
import zipfile
from urllib.parse import urlparse
import sys

def extract_sessions_from_saz(saz_file_path, allowed_hosts, skip_file_types):
    sessions = {}

    try:
        with zipfile.ZipFile(saz_file_path, 'r') as saz_file:
            for file_info in saz_file.infolist():
                if file_info.filename.endswith('_c.txt'):
                    session_id = file_info.filename.replace('_c.txt', '')
                    try:
                        with saz_file.open(file_info) as file:
                            session_data = file.read().decode('utf-8')

                            if any(ext in session_data.lower() for ext in skip_file_types):
                                continue

                            lines = session_data.split('\n')
                            host_line = next((line for line in lines if line.lower().startswith('host:')), None)
                            if not host_line:
                                continue

                            host = host_line.split(':', 1)[1].strip()

                            if allowed_hosts and host not in allowed_hosts:
                                continue

                            sessions[session_id] = {'data': session_data, 'comment': '', 'status_code': None}
                    except UnicodeDecodeError:
                        continue

                elif file_info.filename.endswith('_m.xml') or file_info.filename.endswith('_s.txt'):
                    session_id = file_info.filename.replace('_m.xml', '').replace('_s.txt', '')
                    if session_id not in sessions:
                        continue

                    if file_info.filename.endswith('_m.xml'):
                        with saz_file.open(file_info) as file:
                            xml_data = file.read().decode('utf-8')
                            root = ET.fromstring(xml_data)
                            ui_comment_element = root.find(".//SessionFlag[@N='ui-comments']")
                            ui_comment = ui_comment_element.get('V') if ui_comment_element is not None else ''
                            sessions[session_id]['comment'] = ui_comment

                    elif file_info.filename.endswith('_s.txt'):
                        with saz_file.open(file_info, 'r') as file:
                            lines = file.readlines()
                            status_line = lines[0].decode('utf-8').strip()
                            status_code = status_line.split(' ')[1]
                            sessions[session_id]['status_code'] = status_code

    except Exception as e:
        print(f"Error extracting sessions: {e}")

    return sessions

def parse_fiddler_session(session_data):
    try:
        lines = session_data['data'].strip().split('\r\n')
        request_line_parts = lines[0].split(' ')
        request_method = request_line_parts[0]
        url = request_line_parts[1]
        headers = {}
        body_start = False
        body = ''
        comment = session_data['comment']
        status_code = session_data.get('status_code')

        for line in lines[1:]:
            if line.strip() == '':
                body_start = True
                continue
            if body_start:
                body += line + '\n'
            else:
                if ':' in line:
                    key, value = line.split(':', 1)
                    headers[key.strip()] = value.strip()

        return request_method, url, headers, body.strip(), comment, status_code
    except Exception as e:
        print(f"Error parsing session: {e}")
        return None, None, None, None, None, None

def parse_url(url):
    try:
        parsed = urlparse(url)
        domain = parsed.netloc.split(':')[0]
        path = parsed.path
        return domain, path
    except Exception as e:
        print(f"Error parsing URL: {e}")
        return None, None

def generate_jmeter_test_plan(sessions, allowed_hosts, allowed_status_codes, saz_file_path):
    try:
        test_plan = ET.Element('jmeterTestPlan', version="1.2", properties="5.0", jmeter="5.5")
        hash_tree_main = ET.SubElement(test_plan, 'hashTree')

        test_plan_elem = ET.SubElement(hash_tree_main, 'TestPlan', guiclass="TestPlanGui", testclass="TestPlan", testname="Test Plan", enabled="true")
        ET.SubElement(test_plan_elem, 'stringProp', name="TestPlan.comments")
        ET.SubElement(test_plan_elem, 'boolProp', name="TestPlan.functional_mode").text = "false"
        ET.SubElement(test_plan_elem, 'boolProp', name="TestPlan.tearDown_on_shutdown").text = "true"
        ET.SubElement(test_plan_elem, 'boolProp', name="TestPlan.serialize_threadgroups").text = "false"
        user_defined_vars = ET.SubElement(test_plan_elem, 'elementProp', name="TestPlan.user_defined_variables", elementType="Arguments", guiclass="ArgumentsPanel", testclass="Arguments", testname="User Defined Variables", enabled="true")
        ET.SubElement(user_defined_vars, 'collectionProp', name="Arguments.arguments")
        ET.SubElement(test_plan_elem, 'stringProp', name="TestPlan.user_define_classpath")

        hash_tree_after_test_plan = ET.SubElement(hash_tree_main, 'hashTree')

        thread_group = ET.SubElement(hash_tree_after_test_plan, 'ThreadGroup', guiclass="ThreadGroupGui", testclass="ThreadGroup", testname="Thread Group", enabled="true")
        ET.SubElement(thread_group, 'stringProp', name="ThreadGroup.on_sample_error").text = "continue"
        loop_controller = ET.SubElement(thread_group, 'elementProp', name="ThreadGroup.main_controller", elementType="LoopController", guiclass="LoopControlPanel", testclass="LoopController", testname="Loop Controller", enabled="true")
        ET.SubElement(loop_controller, 'boolProp', name="LoopController.continue_forever").text = "false"
        ET.SubElement(loop_controller, 'stringProp', name="LoopController.loops").text = "1"
        ET.SubElement(thread_group, 'stringProp', name="ThreadGroup.num_threads").text = "1"
        ET.SubElement(thread_group, 'stringProp', name="ThreadGroup.ramp_time").text = "1"
        ET.SubElement(thread_group, 'boolProp', name="ThreadGroup.scheduler").text = "false"
        ET.SubElement(thread_group, 'boolProp', name="ThreadGroup.same_user_on_next_iteration").text = "true"

        hash_tree_for_samplers = ET.SubElement(hash_tree_after_test_plan, 'hashTree')

        current_transaction_controller = None
        last_comment = None

        for session_id, session_data in sessions.items():
            request_method, url, headers, body, comment, status_code = parse_fiddler_session(session_data)
            domain, path = parse_url(url)

            if not domain:
                continue

            if (allowed_hosts and domain not in allowed_hosts) or (allowed_status_codes and status_code not in allowed_status_codes):
                continue

            if comment != last_comment:
                current_transaction_controller = ET.SubElement(hash_tree_for_samplers, 'TransactionController', guiclass="TransactionControllerGui", testclass="TransactionController", testname=comment or "Group", enabled="true")
                ET.SubElement(current_transaction_controller, 'boolProp', name="TransactionController.includeTimers").text = "false"
                ET.SubElement(current_transaction_controller, 'boolProp', name="TransactionController.parent").text = "false"
                hash_tree_for_transaction = ET.SubElement(hash_tree_for_samplers, 'hashTree')

            http_sampler = ET.SubElement(hash_tree_for_transaction, 'HTTPSamplerProxy', guiclass="HttpTestSampleGui", testclass="HTTPSamplerProxy", testname=f"{request_method} {path}", enabled="true")

            if request_method == 'POST':
                ET.SubElement(http_sampler, 'boolProp', name="HTTPSampler.postBodyRaw").text = "true"
                arguments = ET.SubElement(http_sampler, 'elementProp', name="HTTPsampler.Arguments", elementType="Arguments")
                collection_prop = ET.SubElement(arguments, 'collectionProp', name="Arguments.arguments")
                arg_element = ET.SubElement(collection_prop, 'elementProp', name="", elementType="HTTPArgument")
                ET.SubElement(arg_element, 'boolProp', name="HTTPArgument.always_encode").text = "false"
                ET.SubElement(arg_element, 'stringProp', name="Argument.value").text = body
                ET.SubElement(arg_element, 'stringProp', name="Argument.metadata").text = "="

            ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.domain").text = domain
            if url.startswith('http://'):
                ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.port").text = "80"
                ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.protocol").text = "http"
            else:
                ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.port").text = "443"
                ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.protocol").text = "https"

            ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.path").text = path
            ET.SubElement(http_sampler, 'stringProp', name="HTTPSampler.method").text = request_method
            ET.SubElement(http_sampler, 'boolProp', name="HTTPSampler.follow_redirects").text = "true"
            ET.SubElement(http_sampler, 'boolProp', name="HTTPSampler.auto_redirects").text = "false"
            ET.SubElement(http_sampler, 'boolProp', name="HTTPSampler.use_keepalive").text = "true"
            ET.SubElement(http_sampler, 'boolProp', name="HTTPSampler.DO_MULTIPART_POST").text = "false"

            ET.SubElement(hash_tree_for_transaction, 'hashTree')

            last_comment = comment

        jmx_file_path = os.path.splitext(saz_file_path)[0] + '.jmx'
        tree = ET.ElementTree(test_plan)
        tree.write(jmx_file_path, encoding="utf-8", xml_declaration=True)

    except Exception as e:
        print(f"Error generating JMeter test plan: {e}")

if __name__ == "__main__":
    saz_file_path = sys.argv[1]

    allowed_hosts = sys.argv[2].split(',') if len(sys.argv) > 2 and sys.argv[2] else []
    allowed_status_codes = ["200", "302"]
    skip_file_types = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.css', '.js', '.woff', '.woff2', '.ttf', '.otf', '.svg']

    sessions = extract_sessions_from_saz(saz_file_path, allowed_hosts, skip_file_types)

    # If no allowed_hosts provided, accept all
    if not allowed_hosts:
        allowed_hosts = list({parse_url(parse_fiddler_session(data)[1])[0] for data in sessions.values()})

    generate_jmeter_test_plan(sessions, allowed_hosts, allowed_status_codes, saz_file_path)

    # Print unique hosts used
    all_hosts = {parse_url(parse_fiddler_session(data)[1])[0] for data in sessions.values()}
    print("\nâœ… JMeter test plan generated successfully!")
    print("ðŸ“¡ Unique hosts in the JMX file:")
    for host in sorted(all_hosts):
        print(f" - {host}")
